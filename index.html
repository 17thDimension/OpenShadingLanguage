<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Open Shading Language by imageworks</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Open Shading Language</h1>
        <p>Advanced shading language for production GI renderers</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/imageworks/OpenShadingLanguage" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/imageworks/OpenShadingLanguage/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/imageworks/OpenShadingLanguage/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h2>Table of contents</h2>

<ul>
<li>Introduction</li>
<li>How OSL is different</li>
<li>What OSL consists of</li>
<li>Building OSL</li>
<li>Current state of the project and road map</li>
<li>Contacts</li>
<li>Credits</li>
</ul><h2>Introduction</h2>

<p>Welcome to Open Shading Language!</p>

<p>Open Shading Language (OSL) is a small but rich language for
programmable shading in advanced renderers and other applications, ideal
for describing materials, lights, displacement, and pattern generation.</p>

<p>OSL was developed by Sony Pictures Imageworks for use in its in-house
renderer used for feature film animation and visual effects. The
language specification was developed with input by other visual effects
and animation studios who also wish to use it.</p>

<p>OSL is robust and production-proven, and was the exclusive shading
system for big VFX films such as "Men in Black 3: and "The Amazing
Spider-Man," animated features such as "Hotel Transylvania", and several
other films currently in production.</p>

<p>OSL is distributed under the "New BSD" license (see the "LICENSE" file
that comes with the distribution).  In short, you are free to use it in
your own applications, whether they are free or commercial, open or
proprietary, as well as to modify the OSL code as you desire, provided
that you retain the original copyright notices as described in the
license.</p>

<h2>How OSL is different</h2>

<p>OSL has syntax similar to C, as well as other shading languages.
However, it is specifically designed for advanced rendering algorithms
and has features such as radiance closures, BSDFs, and deferred ray
tracing as first-class concepts.</p>

<p>OSL has several unique characteristics not found in other shading
languages (certainly not all together).  Here are some things you will
find are different in OSL compared to other languages:</p>

<ul>
<li>
<p>Surface and volume shaders compute radiance closures, not final colors.</p>

<p>OSL's surface and volume shaders compute an explicit symbolic
description, called a "closure", of the way a surface or volume
scatters light, in units of radiance.  These radiance closures may be
evaluated in particular directions, sampled to find important
directions, or saved for later evaluation and re-evaluation.
This new approach is ideal for a physically-based renderer that
supports ray tracing and global illumination.</p>

<p>In contrast, other shading languages usually compute just a surface
color as visible from a particular direction.  These old shaders are
"black boxes" that a renderer can do little with but execute to find
this one piece of information (for example, there is no effective way
to discover from them which directions are important to sample).
Furthermore, the physical units of lights and surfaces are often
underspecified, making it very difficult to ensure that shaders are
behaving in a physically correct manner.</p>
</li>
<li>
<p>Surface and volume shaders do not loop over lights or shoot rays.</p>

<p>There are no "light loops" or explicitly traced illumination rays in
OSL surface shaders.  Instead, surface shaders compute a radiance
closure describing how the surface scatters light, and a part of the
renderer called an "integrator" evaluates the closures for a
particular set of light sources and determines in which directions
rays should be traced.  Effects that would ordinarily require explicit
ray tracing, such as reflection and refraction, are simply part of the
radiance closure and look like any other BSDF.</p>

<p>Advantages of this approach include that integration and sampling may
be batched or re-ordered to increase ray coherence; a "ray budget" can
be allocated to optimally sample the BSDF; the closures may be used by
for bidirectional ray tracing or Metropolis light transport; and the
closures may be rapidly re-evaluated with new lighting without having
to re-run the shaders.</p>
</li>
<li>
<p>Surface and light shaders are the same thing.</p>

<p>OSL does not have a separate kind of shader for light sources.  Lights
are simply surfaces that are emissive, and all lights are area lights.</p>
</li>
<li>
<p>Transparency is just another kind of illumination.</p>

<p>You don't need to explicitly set transparency/opacity variables in the
shader.  Transparency is just another way for light to interact with a
surface, and is included in the main radiance closure computed by a
surface shader.</p>
</li>
<li>
<p>Renderer outputs (AOV's) may be specified using "light path expressions."</p>

<p>Sometimes it is desirable to output images containing individual
lighting components such as specular, diffuse, reflection, individual
lights, etc.  In other languages, this is usually accomplished by
adding a plethora of "output variables" to the shaders that collect
these individual quantities.</p>

<p>OSL shaders need not be cluttered with any code or output variables to
accomplish this.  Instead, there is a regular-expression-based
notation for describing which light paths should contribute to which
outputs.  This is all done on the renderer side (though supported by
the OSL implementation).  If you desire a new output, there is no need
to modify the shaders at all; you only need to tell the renderer the
new light path expression.</p>
</li>
<li>
<p>Shaders are organized into networks.</p>

<p>OSL shaders are not monolithic, but rather can be organized into
networks of shaders (sometimes called a shader group, graph, or DAG),
with named outputs of some nodes being connected to named inputs of
other nodes within the network.  These connections may be done
dynamically at render time, and do not affect compilation of
individual shader nodes.  Furthermore, the individual nodes are
evaluated lazily, only when their outputs are "pulled" from the later
nodes that depend on them (shader writers may remain blissfully
unaware of these details, and write shaders as if everything is
evaluated normally).</p>
</li>
<li>
<p>Arbitrary derivatives without grids or extra shading points.</p>

<p>In OSL, you can take derivatives of any computed quantity in a shader,
and use arbitrary quantities as texture coordinates and expect correct
filtering.  This does not require that shaded points be arranged in a
rectangular grid, or have any particular connectivity, or that any
"extra points" be shaded.  This is because derivatives are not
computed by finite differences with neighboring points, but rather by
"automatic differentiation", computing partial differentials for the
variables that lead to derivatives, without any intervention required
by the shader writer.</p>
</li>
<li>
<p>OSL optimizes aggressively at render time</p>

<p>OSL uses the LLVM compiler framework to translate shader networks into
machine code on the fly (just in time, or "JIT"), and in the process
heavily optimizes shaders and networks with full knowledge of the
shader parameters and other runtime values that could not have been
known when the shaders were compiled from source code.  As a result,
we are seeing our OSL shading networks execute 25% faster than the
equivalent shaders hand-crafted in C!  (That's how our old shaders
worked in our renderer.)</p>
</li>
</ul><h2>What OSL consists of</h2>

<p>The OSL open source distribution consists of the following components:</p>

<ul>
<li><p>oslc, a standalone compiler that translates OSL source code into
an assembly-like intermediate code (in the form of .oso files).</p></li>
<li><p>liboslc, a library that implements the OSLCompiler class, which
contains the guts of the shader compiler, in case anybody needs to
embed it into other applications and does not desire for the compiler
to be a separate executable.</p></li>
<li><p>liboslquery, a library that implements the OSLQuery class, which
allows applications to query information about compiled shaders,
including a full list of its parameters, their types, and any metadata
associated with them.</p></li>
<li><p>oslinfo, a command-line program that uses liboslquery to print to the
console all the relevant information about a shader and its parameters.</p></li>
<li><p>liboslexec, a library that implements the ShadingSystem class, which
allows compiled shaders to be executed within an application.
Currently, it uses LLVM to JIT compile the shader bytecode to x86
instructions.</p></li>
<li><p>testshade, a program that lets you execute a shader (or connected
shader network) on a rectangular array of points, and save any of its
outputs as images.  This allows for verification of shaders (and the
shading system) without needing to be integrated into a fully
functional renderer, and is the basis for most of our testsuite
verification.  Along with testrender, testshade is a good example
of how to call the OSL libraries.</p></li>
<li><p>testrender, a tiny ray-tracing renderer that uses OSL for shading.
Features are very minimal (only spheres are permitted at this time)
and there has been no attention to performance, but it demonstrates how
the OSL libraries may be integrated into a working renderer, what
interfaces the renderer needs to supply, and how the BSDFs/radiance
closures should be evaluated and integrated (including with multiple
importance sampling).</p></li>
<li><p>A few sample shaders.</p></li>
<li><p>Documentation -- at this point consisting of the OSL language
specification (useful for shader writers), but in the future will have
detailed documentation about how to integrate the OSL libraries into
renderers.</p></li>
</ul><h2>Building OSL</h2>

<p>Please see the "INSTALL" file in the OSL distribution for instructions
for building the OSL source code.</p>

<h2>Current state of the project and road map</h2>

<p>At Sony Pictures Imageworks, we are exclusively using OSL in our
proprietary renderer, "Arnold."  Completed productions that used 100%
OSL for their shading include Men in Black 3, The Amazing Spider-Man,
and Hotel Transylvania, and other unreleased shows that are still in
production.  Our shader-writing team works entirely in OSL, all
productions use OSL, and we've even removed all the code from the
renderer that allows people to write the old-style "C" shaders.  At the
time we removed the old shader facility, the OSL shaders were
consistently outperforming their equivalent old compiled C shaders in
the old system.</p>

<p>In the longer term, there are a number of projects we hope to get to
leading to a 2.x or 3.x cut of the language and library.  Among our
long-term goals:</p>

<ul>
<li><p>More documentation, in particular the "Integration Guide" that
documents all the public APIs of the OSL libraries that you use when
integrating into a renderer.  Currently, the source code to
"testrender" is the best/only example of how to integrate OSL into a
renderer.</p></li>
<li><p>Our set of sample shaders is quite anemic.  We will eventually have a
more extensive set of useful, production-quality shaders and utility
functions you can call from your shaders.</p></li>
<li><p>Currently "closure primitives" are implemented in C++ in the OSL
library or in the renderer, but we would like a future spec of the
language to allow new closure primitives to be implemented in OSL
itself.</p></li>
<li><p>Similarly, integrators are now implemented in the renderer, but we
want a future OSL release to allow new integrators to be implemented
in OSL itself.</p></li>
<li><p>We would like to implement alternate "back ends" that would allow
translation of OSL shaders (and shader networks) into code that can
run on GPUs or other exotic hardware (at least for the biggest subset
of OSL that can be expressed on such hardware).  This would, for
example, allow you to view close approximations to your OSL shaders in
realtime preview windows in a modeling system or lighting tool.</p></li>
</ul><p>We (the renderer development team at Sony Pictures Imageworks) probably
can't do these all right away (in fact, probably can't do ALL of them in
any time range).  But we hope that as an open source project, other
users and developers will step up to help us explore more future
development avenues for OSL than we would be able to do alone.</p>

<h2>Contacts</h2>

<p><a href="http://opensource.imageworks.com/?p=osl">OSL home page at SPI</a></p>

<p><a href="https://github.com/imageworks/OpenShadingLanguage">OSL GitHub page</a></p>

<p><a href="http://groups.google.com/group/osl-dev">Read or subscribe to the OSL development mail list</a></p>

<p>Email the lead architect:  lg AT imageworks DOT com</p>

<p><a href="https://github.com/imageworks/OpenShadingLanguage/blob/master/src/doc/osl-languagespec.pdf">Most recent PDF of the OSL language specification</a></p>

<p><a href="http://opensource.imageworks.com">Sony Pictures Imageworks main open source page</a></p>

<p>If you want to contribute code back to the project, you'll need to
sign <a href="http://opensource.imageworks.com/cla/">a Contributor License Agreement</a>.</p>

<h2>Credits</h2>

<p>The main developers of OSL are (in order of joining the project):</p>

<ul>
<li><p>Larry Gritz</p></li>
<li><p>Cliff Stein</p></li>
<li><p>Chris Kulla</p></li>
<li><p>Alejandro Conty</p></li>
<li><p>Jay Reynolds</p></li>
<li><p>Solomon Boulos</p></li>
<li><p>Adam Martinez</p></li>
</ul><p>We cannot possibly express sufficient gratitude to the managers at Sony
Pictures Imageworks who allowed this project to proceed, supported it
wholeheartedly, and permitted us to release the source, especially Rob
Bredow, Brian Keeney, Barbara Ford, and Rene Limberger.</p>

<p>Huge thanks also go to the crack shading team at SPI, and the brave
lookdev TDs and CG supes willing to use OSL on their shows.  They served
as our guinea pigs, inspiration, testers, and a fantastic source of
feedback.  Thank you, and we hope we've been responsive to your needs.</p>

<p>OSL was not developed in isolation.  We owe a debt to the individuals
and studios who patiently read early drafts of the language
specification and gave us very helpful feedback and additional ideas.
(I hope to mention them by name after we get permission of the people
and studios involved.)</p>

<p>The OSL implementation incorporates or depends upon several other open
source packages:</p>

<p><a href="http://www.openimageio.org">OpenImageIO (c) Larry Gritz, et al</a></p>

<p><a href="http://www.boost.org">Boost - various authors</a></p>

<p><a href="http://www.openexr.com">IlmBase (c) Industrial Light &amp; Magic</a></p>

<p><a href="http://llvm.org">LLVM Compiler Infrastructure</a></p>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/imageworks">imageworks</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="http://twitter.com/#!/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>