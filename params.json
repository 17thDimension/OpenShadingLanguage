{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"Table of contents\r\n------------------\r\n\r\n* Introduction\r\n* How OSL is different\r\n* What OSL consists of\r\n* Building OSL\r\n* Current state of the project and road map\r\n* Contacts\r\n* Credits\r\n\r\n\r\nIntroduction\r\n------------\r\n\r\nWelcome to Open Shading Language!\r\n\r\nOpen Shading Language (OSL) is a small but rich language for\r\nprogrammable shading in advanced renderers and other applications, ideal\r\nfor describing materials, lights, displacement, and pattern generation.\r\n\r\nOSL was developed by Sony Pictures Imageworks for use in its in-house\r\nrenderer used for feature film animation and visual effects. The\r\nlanguage specification was developed with input by other visual effects\r\nand animation studios who also wish to use it.\r\n\r\nOSL is robust and production-proven, and was the exclusive shading\r\nsystem for big VFX films such as \"Men in Black 3: and \"The Amazing\r\nSpider-Man,\" animated features such as \"Hotel Transylvania\", and several\r\nother films currently in production.\r\n\r\nOSL is distributed under the \"New BSD\" license (see the \"LICENSE\" file\r\nthat comes with the distribution).  In short, you are free to use it in\r\nyour own applications, whether they are free or commercial, open or\r\nproprietary, as well as to modify the OSL code as you desire, provided\r\nthat you retain the original copyright notices as described in the\r\nlicense.\r\n\r\n\r\n\r\nHow OSL is different\r\n--------------------\r\n\r\nOSL has syntax similar to C, as well as other shading languages.\r\nHowever, it is specifically designed for advanced rendering algorithms\r\nand has features such as radiance closures, BSDFs, and deferred ray\r\ntracing as first-class concepts.\r\n\r\nOSL has several unique characteristics not found in other shading\r\nlanguages (certainly not all together).  Here are some things you will\r\nfind are different in OSL compared to other languages:\r\n\r\n* Surface and volume shaders compute radiance closures, not final colors.\r\n\r\n  OSL's surface and volume shaders compute an explicit symbolic\r\n  description, called a \"closure\", of the way a surface or volume\r\n  scatters light, in units of radiance.  These radiance closures may be\r\n  evaluated in particular directions, sampled to find important\r\n  directions, or saved for later evaluation and re-evaluation.\r\n  This new approach is ideal for a physically-based renderer that\r\n  supports ray tracing and global illumination.\r\n\r\n  In contrast, other shading languages usually compute just a surface\r\n  color as visible from a particular direction.  These old shaders are\r\n  \"black boxes\" that a renderer can do little with but execute to find\r\n  this one piece of information (for example, there is no effective way\r\n  to discover from them which directions are important to sample).\r\n  Furthermore, the physical units of lights and surfaces are often\r\n  underspecified, making it very difficult to ensure that shaders are\r\n  behaving in a physically correct manner.\r\n\r\n* Surface and volume shaders do not loop over lights or shoot rays.\r\n\r\n  There are no \"light loops\" or explicitly traced illumination rays in\r\n  OSL surface shaders.  Instead, surface shaders compute a radiance\r\n  closure describing how the surface scatters light, and a part of the\r\n  renderer called an \"integrator\" evaluates the closures for a\r\n  particular set of light sources and determines in which directions\r\n  rays should be traced.  Effects that would ordinarily require explicit\r\n  ray tracing, such as reflection and refraction, are simply part of the\r\n  radiance closure and look like any other BSDF.\r\n\r\n  Advantages of this approach include that integration and sampling may\r\n  be batched or re-ordered to increase ray coherence; a \"ray budget\" can\r\n  be allocated to optimally sample the BSDF; the closures may be used by\r\n  for bidirectional ray tracing or Metropolis light transport; and the\r\n  closures may be rapidly re-evaluated with new lighting without having\r\n  to re-run the shaders.\r\n\r\n* Surface and light shaders are the same thing.\r\n\r\n  OSL does not have a separate kind of shader for light sources.  Lights\r\n  are simply surfaces that are emissive, and all lights are area lights.\r\n\r\n* Transparency is just another kind of illumination.\r\n\r\n  You don't need to explicitly set transparency/opacity variables in the\r\n  shader.  Transparency is just another way for light to interact with a\r\n  surface, and is included in the main radiance closure computed by a\r\n  surface shader.\r\n\r\n* Renderer outputs (AOV's) may be specified using \"light path expressions.\"\r\n\r\n  Sometimes it is desirable to output images containing individual\r\n  lighting components such as specular, diffuse, reflection, individual\r\n  lights, etc.  In other languages, this is usually accomplished by\r\n  adding a plethora of \"output variables\" to the shaders that collect\r\n  these individual quantities.\r\n\r\n  OSL shaders need not be cluttered with any code or output variables to\r\n  accomplish this.  Instead, there is a regular-expression-based\r\n  notation for describing which light paths should contribute to which\r\n  outputs.  This is all done on the renderer side (though supported by\r\n  the OSL implementation).  If you desire a new output, there is no need\r\n  to modify the shaders at all; you only need to tell the renderer the\r\n  new light path expression.\r\n\r\n* Shaders are organized into networks.\r\n\r\n  OSL shaders are not monolithic, but rather can be organized into\r\n  networks of shaders (sometimes called a shader group, graph, or DAG),\r\n  with named outputs of some nodes being connected to named inputs of\r\n  other nodes within the network.  These connections may be done\r\n  dynamically at render time, and do not affect compilation of\r\n  individual shader nodes.  Furthermore, the individual nodes are\r\n  evaluated lazily, only when their outputs are \"pulled\" from the later\r\n  nodes that depend on them (shader writers may remain blissfully\r\n  unaware of these details, and write shaders as if everything is\r\n  evaluated normally).\r\n\r\n* Arbitrary derivatives without grids or extra shading points.\r\n\r\n  In OSL, you can take derivatives of any computed quantity in a shader,\r\n  and use arbitrary quantities as texture coordinates and expect correct\r\n  filtering.  This does not require that shaded points be arranged in a\r\n  rectangular grid, or have any particular connectivity, or that any\r\n  \"extra points\" be shaded.  This is because derivatives are not\r\n  computed by finite differences with neighboring points, but rather by\r\n  \"automatic differentiation\", computing partial differentials for the\r\n  variables that lead to derivatives, without any intervention required\r\n  by the shader writer.\r\n\r\n* OSL optimizes aggressively at render time\r\n\r\n  OSL uses the LLVM compiler framework to translate shader networks into\r\n  machine code on the fly (just in time, or \"JIT\"), and in the process\r\n  heavily optimizes shaders and networks with full knowledge of the\r\n  shader parameters and other runtime values that could not have been\r\n  known when the shaders were compiled from source code.  As a result,\r\n  we are seeing our OSL shading networks execute 25% faster than the\r\n  equivalent shaders hand-crafted in C!  (That's how our old shaders\r\n  worked in our renderer.)\r\n\r\n\r\n\r\nWhat OSL consists of\r\n--------------------\r\n\r\nThe OSL open source distribution consists of the following components:\r\n\r\n* oslc, a standalone compiler that translates OSL source code into\r\n  an assembly-like intermediate code (in the form of .oso files).\r\n\r\n* liboslc, a library that implements the OSLCompiler class, which\r\n  contains the guts of the shader compiler, in case anybody needs to\r\n  embed it into other applications and does not desire for the compiler\r\n  to be a separate executable.\r\n\r\n* liboslquery, a library that implements the OSLQuery class, which\r\n  allows applications to query information about compiled shaders,\r\n  including a full list of its parameters, their types, and any metadata\r\n  associated with them.\r\n\r\n* oslinfo, a command-line program that uses liboslquery to print to the\r\n  console all the relevant information about a shader and its parameters.\r\n\r\n* liboslexec, a library that implements the ShadingSystem class, which\r\n  allows compiled shaders to be executed within an application.\r\n  Currently, it uses LLVM to JIT compile the shader bytecode to x86\r\n  instructions.\r\n\r\n* testshade, a program that lets you execute a shader (or connected\r\n  shader network) on a rectangular array of points, and save any of its\r\n  outputs as images.  This allows for verification of shaders (and the\r\n  shading system) without needing to be integrated into a fully\r\n  functional renderer, and is the basis for most of our testsuite\r\n  verification.  Along with testrender, testshade is a good example\r\n  of how to call the OSL libraries.\r\n\r\n* testrender, a tiny ray-tracing renderer that uses OSL for shading.\r\n  Features are very minimal (only spheres are permitted at this time)\r\n  and there has been no attention to performance, but it demonstrates how\r\n  the OSL libraries may be integrated into a working renderer, what\r\n  interfaces the renderer needs to supply, and how the BSDFs/radiance\r\n  closures should be evaluated and integrated (including with multiple\r\n  importance sampling).\r\n\r\n* A few sample shaders.\r\n\r\n* Documentation -- at this point consisting of the OSL language\r\n  specification (useful for shader writers), but in the future will have\r\n  detailed documentation about how to integrate the OSL libraries into\r\n  renderers.\r\n\r\n\r\n\r\nBuilding OSL\r\n------------\r\n\r\nPlease see the \"INSTALL\" file in the OSL distribution for instructions\r\nfor building the OSL source code.\r\n\r\n\r\n\r\nCurrent state of the project and road map\r\n-----------------------------------------\r\n\r\nAt Sony Pictures Imageworks, we are exclusively using OSL in our\r\nproprietary renderer, \"Arnold.\"  Completed productions that used 100%\r\nOSL for their shading include Men in Black 3, The Amazing Spider-Man,\r\nand Hotel Transylvania, and other unreleased shows that are still in\r\nproduction.  Our shader-writing team works entirely in OSL, all\r\nproductions use OSL, and we've even removed all the code from the\r\nrenderer that allows people to write the old-style \"C\" shaders.  At the\r\ntime we removed the old shader facility, the OSL shaders were\r\nconsistently outperforming their equivalent old compiled C shaders in\r\nthe old system.\r\n\r\nIn the longer term, there are a number of projects we hope to get to\r\nleading to a 2.x or 3.x cut of the language and library.  Among our\r\nlong-term goals:\r\n\r\n* More documentation, in particular the \"Integration Guide\" that\r\n  documents all the public APIs of the OSL libraries that you use when\r\n  integrating into a renderer.  Currently, the source code to\r\n  \"testrender\" is the best/only example of how to integrate OSL into a\r\n  renderer.\r\n\r\n* Our set of sample shaders is quite anemic.  We will eventually have a\r\n  more extensive set of useful, production-quality shaders and utility\r\n  functions you can call from your shaders.\r\n\r\n* Currently \"closure primitives\" are implemented in C++ in the OSL\r\n  library or in the renderer, but we would like a future spec of the\r\n  language to allow new closure primitives to be implemented in OSL\r\n  itself.\r\n\r\n* Similarly, integrators are now implemented in the renderer, but we\r\n  want a future OSL release to allow new integrators to be implemented\r\n  in OSL itself.\r\n\r\n* We would like to implement alternate \"back ends\" that would allow\r\n  translation of OSL shaders (and shader networks) into code that can\r\n  run on GPUs or other exotic hardware (at least for the biggest subset\r\n  of OSL that can be expressed on such hardware).  This would, for\r\n  example, allow you to view close approximations to your OSL shaders in\r\n  realtime preview windows in a modeling system or lighting tool.\r\n\r\nWe (the renderer development team at Sony Pictures Imageworks) probably\r\ncan't do these all right away (in fact, probably can't do ALL of them in\r\nany time range).  But we hope that as an open source project, other\r\nusers and developers will step up to help us explore more future\r\ndevelopment avenues for OSL than we would be able to do alone.\r\n\r\n\r\n\r\nContacts\r\n--------\r\n\r\n[OSL home page at SPI](http://opensource.imageworks.com/?p=osl)\r\n\r\n\r\n[OSL GitHub page](https://github.com/imageworks/OpenShadingLanguage)\r\n\r\n[Read or subscribe to the OSL development mail list](http://groups.google.com/group/osl-dev)\r\n\r\nEmail the lead architect:  lg AT imageworks DOT com\r\n\r\n[Most recent PDF of the OSL language specification](https://github.com/imageworks/OpenShadingLanguage/blob/master/src/doc/osl-languagespec.pdf\r\n)\r\n\r\n[Sony Pictures Imageworks main open source page](http://opensource.imageworks.com)\r\n\r\nIf you want to contribute code back to the project, you'll need to\r\nsign [a Contributor License Agreement](http://opensource.imageworks.com/cla/).\r\n\r\n\r\nCredits\r\n-------\r\n\r\nThe main developers of OSL are (in order of joining the project):\r\n\r\n* Larry Gritz\r\n\r\n* Cliff Stein\r\n\r\n* Chris Kulla\r\n\r\n* Alejandro Conty\r\n\r\n* Jay Reynolds\r\n\r\n* Solomon Boulos\r\n\r\n* Adam Martinez\r\n\r\nWe cannot possibly express sufficient gratitude to the managers at Sony\r\nPictures Imageworks who allowed this project to proceed, supported it\r\nwholeheartedly, and permitted us to release the source, especially Rob\r\nBredow, Brian Keeney, Barbara Ford, and Rene Limberger.\r\n\r\nHuge thanks also go to the crack shading team at SPI, and the brave\r\nlookdev TDs and CG supes willing to use OSL on their shows.  They served\r\nas our guinea pigs, inspiration, testers, and a fantastic source of\r\nfeedback.  Thank you, and we hope we've been responsive to your needs.\r\n\r\nOSL was not developed in isolation.  We owe a debt to the individuals\r\nand studios who patiently read early drafts of the language\r\nspecification and gave us very helpful feedback and additional ideas.\r\n(I hope to mention them by name after we get permission of the people\r\nand studios involved.)\r\n\r\nThe OSL implementation incorporates or depends upon several other open\r\nsource packages:\r\n\r\n[OpenImageIO (c) Larry Gritz, et al](http://www.openimageio.org)\r\n\r\n[Boost - various authors](http://www.boost.org)\r\n\r\n[IlmBase (c) Industrial Light & Magic](http://www.openexr.com)\r\n\r\n[LLVM Compiler Infrastructure](http://llvm.org)\r\n\r\n\r\n","name":"Open Shading Language","tagline":"Advanced shading language for production GI renderers","google":""}